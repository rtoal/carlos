Carlos {
  Program     = Statement+

  Statement   = Declaration
              | Assignment
              | Call
              | break
              | return Exp?                         --return
              | IfStmt
              | ForStmt

  Declaration = VarDecl | StructDecl | FunDecl 
  VarDecl     = (let | const) id "=" Exp
  StructDecl  = struct id "{" Field* "}"
  Field       = id ":" TypeExp
  FunDecl     = function id Params (":" TypeExp)? Block
  Params      = "(" ListOf<Param, ","> ")"
  Param       = id ":" TypeExp

  TypeExp     = "[" TypeExp "]"                     --array
              | "(" TypeExps ")" "->" TypeExp       --function
              | TypeExp "?"                         --optional
              | id                                  --named
  TypeExps    = ListOf<TypeExp, ",">

  Assignment  = ("++" | "--") Var                   --prefix
              | Var ("++" | "--")                   --postfix
              | Var "=" Exp                         --assign

  IfStmt      = if Exp Block else (Block | IfStmt)  --long
              | if Exp Block                        --short
  ForStmt     = for Block                           --forever
              | for Exp Block                       --while
              | for Exp times Block                 --times
              | for id in Range Block               --iteration
  Block       = "{" Statement* "}"

  Exp         = Exp1 "?" Exp1 ":" Exp               --conditional
              | Exp1
  Exp1        = Exp1 "??" Exp2                      --unwrapelse
              | Exp2
  Exp2        = Exp3 ("||" Exp3)+                   --or
              | Exp3 ("&&" Exp3)+                   --and
              | Exp3
  Exp3        = Exp4 ("|" Exp4)+                    --bitor
              | Exp4 ("^" Exp4)+                    --bitxor
              | Exp4 ("&" Exp4)+                    --bitand
              | Exp4
  Exp4        = Exp5 relop Exp5                     --compare
              | Exp5
  Exp5        = Exp5 ("<<" | ">>") Exp6             --shift
              | Exp6
  Exp6        = Exp6 ("+" | "-") Exp7               --add
              | Exp7
  Exp7        = Exp7 ("*"| "/" | "%") Exp8          --multiply
              | Exp8
  Exp8        = Exp9 "**" Exp8                      --power
              | Exp9
              | "#" Exp9                            --length
              | "-" Exp9                            --negate
  Exp9        = true
              | false
              | floatlit
              | intlit
              | stringlit
              | "emptyArrayOf" "(" TypeExp ")"      --emptyarray
              | "[" NonemptyListOf<Exp, ","> "]"    --arrayexp
              | some Exp                            --wrappedopt
              | no TypeExp                          --emptyopt
              | "(" Exp ")"                         --parens
              | Var
              
  Var         = Var "[" Exp "]"                     --subscript
              | Var "." id                          --member
              | Var  "?." id                        --unwrapmember
              | Call
              | id                                  --id
  Call        = Var "(" ListOf<Exp, ","> ")"

  Range       = Exp ("..." | "..<") Exp             --numeric
              | Exp                                 --collection
  relop       = "<=" | "<" | "==" | "!=" | ">=" | ">"

  intlit      = digit+
  floatlit    = digit+ "." digit+ (("E" | "e") ("+" | "-")? digit+)?
  stringlit   = "\"" char* "\""
  char        = ~"\n" ~"\r" ~"\\" ~"\"" any
              | "\\" ("n" | "t" | "\"" | "\\")      --escape
              | "\\u{" h h? h? h? h? h? "}"         --codepoint
  h           = hexDigit

  let         = "let" ~alnum
  const       = "const" ~alnum
  struct      = "struct" ~alnum
  function    = "function" ~alnum
  if          = "if" ~alnum
  else        = "else" ~alnum
  for         = "for" ~alnum
  in          = "in" ~alnum
  times       = "times" ~alnum
  break       = "break" ~alnum
  return      = "return" ~alnum
  some        = "some" ~alnum
  no          = "no" ~alnum
  true        = "true" ~alnum
  false       = "false" ~alnum
  keyword     = let | const | struct | function | if | else | for | in
              | times | break | return | some | no | true | false
  id          = ~keyword letter alnum*

  space      += "//" (~"\n" any)* ("\n" | end)      --comment
}